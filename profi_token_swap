"""
–ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–π —Å–∫—Ä–∏–ø—Ç –¥–ª—è —Å–≤–∞–ø–∞ —Ç–æ–∫–µ–Ω–æ–≤ —á–µ—Ä–µ–∑ Uniswap UniversalRouter
–° –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º uniswap-universal-router-decoder –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è
"""

import os
import time
from decimal import Decimal
from typing import Optional, Dict, Any, List
from dataclasses import dataclass

from web3 import Web3
from eth_account import Account
from dotenv import load_dotenv
import requests

# –ò–º–ø–æ—Ä—Ç—ã –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å UniversalRouter (—Ç—Ä–µ–±—É–µ—Ç —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –±–∏–±–ª–∏–æ—Ç–µ–∫)
try:
    from uniswap_universal_router_decoder import (
        FunctionRecipient,
        RouterCodec,
        encode_v3_swap
    )

    ROUTER_DECODER_AVAILABLE = True
except ImportError:
    print("‚ö†Ô∏è  –ë–∏–±–ª–∏–æ—Ç–µ–∫–∞ uniswap-universal-router-decoder –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞")
    print("–£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ: pip install uniswap-universal-router-decoder")
    ROUTER_DECODER_AVAILABLE = False


@dataclass
class SwapParams:
    """–ü–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–ª—è —Å–≤–∞–ø–∞"""
    token_in: str
    token_out: str
    amount_in: int
    amount_out_min: int
    recipient: str
    deadline: int
    fee: int = 3000  # 0.3% –∫–æ–º–∏—Å—Å–∏—è –ø—É–ª–∞


class AdvancedUniswapSwapper:
    """–ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–π –∫–ª–∞—Å—Å –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —Å–≤–∞–ø–æ–≤ —á–µ—Ä–µ–∑ UniversalRouter"""

    def __init__(self, private_key: str, rpc_url: str, chain_id: int = 1):
        load_dotenv()

        self.w3 = Web3(Web3.HTTPProvider(rpc_url))
        self.account = Account.from_key(private_key)
        self.chain_id = chain_id

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ
        if not self.w3.is_connected():
            raise ConnectionError("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ RPC")

        print(f"‚úÖ –ü–æ–¥–∫–ª—é—á–µ–Ω –∫ —Å–µ—Ç–∏ {chain_id}")
        print(f"üìç –ê–¥—Ä–µ—Å –∫–æ—à–µ–ª—å–∫–∞: {self.account.address}")
        print(f"üí∞ –ë–∞–ª–∞–Ω—Å ETH: {self.w3.from_wei(self.w3.eth.get_balance(self.account.address), 'ether'):.4f}")

        # –ê–¥—Ä–µ—Å–∞ –∫–æ–Ω—Ç—Ä–∞–∫—Ç–æ–≤
        self.contracts = self._get_contract_addresses()

        # ABI –∫–æ–Ω—Ç—Ä–∞–∫—Ç–æ–≤
        self.erc20_abi = self._get_erc20_abi()
        self.universal_router_abi = self._get_universal_router_abi()

        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –∫–æ–Ω—Ç—Ä–∞–∫—Ç UniversalRouter
        self.universal_router = self.w3.eth.contract(
            address=self.contracts['universal_router'],
            abi=self.universal_router_abi
        )

    def _get_contract_addresses(self) -> Dict[str, str]:
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∞–¥—Ä–µ—Å–∞ –∫–æ–Ω—Ç—Ä–∞–∫—Ç–æ–≤ –¥–ª—è —Ç–µ–∫—É—â–µ–π —Å–µ—Ç–∏"""
        contracts = {
            1: {  # Ethereum
                'universal_router': '0x3fC91A3afd70395Cd496C647d5a6CC9D4B2b7FAD',
                'permit2': '0x000000000022D473030F116dDEE9F6B43aC78BA3',
                'weth': '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2',
                'quoter_v2': '0x61fFE014bA17989E743c5F6cB21bF9697530B21e'
            },
            137: {  # Polygon
                'universal_router': '0xec7BE89e9d109e7e3Fec59c222CF297125FEFda2',
                'permit2': '0x000000000022D473030F116dDEE9F6B43aC78BA3',
                'weth': '0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270',
                'quoter_v2': '0x61fFE014bA17989E743c5F6cB21bF9697530B21e'
            }
        }

        return contracts.get(self.chain_id, contracts[1])

    def _get_erc20_abi(self) -> List[Dict]:
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç ABI –¥–ª—è ERC20 —Ç–æ–∫–µ–Ω–æ–≤"""
        return [
            {
                "constant": True,
                "inputs": [],
                "name": "decimals",
                "outputs": [{"name": "", "type": "uint8"}],
                "type": "function"
            },
            {
                "constant": True,
                "inputs": [],
                "name": "symbol",
                "outputs": [{"name": "", "type": "string"}],
                "type": "function"
            },
            {
                "constant": True,
                "inputs": [{"name": "_owner", "type": "address"}],
                "name": "balanceOf",
                "outputs": [{"name": "balance", "type": "uint256"}],
                "type": "function"
            },
            {
                "constant": False,
                "inputs": [
                    {"name": "_spender", "type": "address"},
                    {"name": "_value", "type": "uint256"}
                ],
                "name": "approve",
                "outputs": [{"name": "", "type": "bool"}],
                "type": "function"
            },
            {
                "constant": True,
                "inputs": [
                    {"name": "_owner", "type": "address"},
                    {"name": "_spender", "type": "address"}
                ],
                "name": "allowance",
                "outputs": [{"name": "", "type": "uint256"}],
                "type": "function"
            }
        ]

    def _get_universal_router_abi(self) -> List[Dict]:
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç ABI –¥–ª—è UniversalRouter"""
        return [
            {
                "inputs": [
                    {"name": "commands", "type": "bytes"},
                    {"name": "inputs", "type": "bytes[]"},
                    {"name": "deadline", "type": "uint256"}
                ],
                "name": "execute",
                "outputs": [],
                "stateMutability": "payable",
                "type": "function"
            }
        ]

    def get_token_info(self, token_address: str) -> Optional[Dict[str, Any]]:
        """–ü–æ–ª—É—á–∞–µ—Ç –¥–µ—Ç–∞–ª—å–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ç–æ–∫–µ–Ω–µ"""
        try:
            contract = self.w3.eth.contract(
                address=Web3.to_checksum_address(token_address),
                abi=self.erc20_abi
            )

            symbol = contract.functions.symbol().call()
            decimals = contract.functions.decimals().call()
            balance = contract.functions.balanceOf(self.account.address).call()

            # –ü—Ä–æ–≤–µ—Ä—è–µ–º allowance –¥–ª—è Permit2
            allowance = contract.functions.allowance(
                self.account.address,
                self.contracts['permit2']
            ).call()

            return {
                'address': token_address,
                'symbol': symbol,
                'decimals': decimals,
                'balance': balance,
                'balance_formatted': balance / (10 ** decimals),
                'allowance': allowance,
                'allowance_formatted': allowance / (10 ** decimals)
            }

        except Exception as e:
            print(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Ç–æ–∫–µ–Ω–µ {token_address}: {e}")
            return None

    def get_quote_from_quoter(self, token_in: str, token_out: str,
                              amount_in: int, fee: int = 3000) -> Optional[int]:
        """
        –ü–æ–ª—É—á–∞–µ—Ç –∫–æ—Ç–∏—Ä–æ–≤–∫—É –Ω–∞–ø—Ä—è–º—É—é –æ—Ç Quoter V2 –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞
        """
        try:
            quoter_abi = [
                {
                    "inputs": [
                        {"name": "tokenIn", "type": "address"},
                        {"name": "tokenOut", "type": "address"},
                        {"name": "fee", "type": "uint24"},
                        {"name": "amountIn", "type": "uint256"},
                        {"name": "sqrtPriceLimitX96", "type": "uint160"}
                    ],
                    "name": "quoteExactInputSingle",
                    "outputs": [
                        {"name": "amountOut", "type": "uint256"},
                        {"name": "sqrtPriceX96After", "type": "uint160"},
                        {"name": "initializedTicksCrossed", "type": "uint32"},
                        {"name": "gasEstimate", "type": "uint256"}
                    ],
                    "stateMutability": "nonpayable",
                    "type": "function"
                }
            ]

            quoter_contract = self.w3.eth.contract(
                address=self.contracts['quoter_v2'],
                abi=quoter_abi
            )

            result = quoter_contract.functions.quoteExactInputSingle(
                token_in,
                token_out,
                fee,
                amount_in,
                0  # sqrtPriceLimitX96 = 0 (no limit)
            ).call()

            return result[0]  # amountOut

        except Exception as e:
            print(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∫–æ—Ç–∏—Ä–æ–≤–∫–∏ –æ—Ç Quoter: {e}")
            return None

    def approve_token_for_permit2(self, token_address: str, amount: int) -> bool:
        """–û–¥–æ–±—Ä—è–µ—Ç —Ç–æ–∫–µ–Ω –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —Å Permit2"""
        try:
            contract = self.w3.eth.contract(
                address=Web3.to_checksum_address(token_address),
                abi=self.erc20_abi
            )

            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–µ–∫—É—â–∏–π allowance
            current_allowance = contract.functions.allowance(
                self.account.address,
                self.contracts['permit2']
            ).call()

            if current_allowance >= amount:
                print(f"‚úÖ –¢–æ–∫–µ–Ω —É–∂–µ –æ–¥–æ–±—Ä–µ–Ω (allowance: {current_allowance})")
                return True

            print(f"üîÑ –û–¥–æ–±—Ä—è–µ–º —Ç–æ–∫–µ–Ω –¥–ª—è Permit2...")

            # –°—Ç—Ä–æ–∏–º —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é –æ–¥–æ–±—Ä–µ–Ω–∏—è
            tx_data = contract.functions.approve(
                self.contracts['permit2'],
                2 ** 256 - 1  # –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –æ–¥–æ–±—Ä–µ–Ω–∏–µ
            ).build_transaction({
                'from': self.account.address,
                'gas': 100000,
                'gasPrice': self.w3.eth.gas_price,
                'nonce': self.w3.eth.get_transaction_count(self.account.address)
            })

            # –ü–æ–¥–ø–∏—Å—ã–≤–∞–µ–º –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º
            signed_tx = self.account.sign_transaction(tx_data)
            tx_hash = self.w3.eth.send_raw_transaction(signed_tx.rawTransaction)

            print(f"üì§ –¢—Ä–∞–Ω–∑–∞–∫—Ü–∏—è –æ–¥–æ–±—Ä–µ–Ω–∏—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞: {tx_hash.hex()}")

            # –ñ–¥–µ–º –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è
            receipt = self.w3.eth.wait_for_transaction_receipt(tx_hash, timeout=300)

            if receipt.status == 1:
                print("‚úÖ –¢–æ–∫–µ–Ω —É—Å–ø–µ—à–Ω–æ –æ–¥–æ–±—Ä–µ–Ω –¥–ª—è Permit2")
                return True
            else:
                print("‚ùå –¢—Ä–∞–Ω–∑–∞–∫—Ü–∏—è –æ–¥–æ–±—Ä–µ–Ω–∏—è –Ω–µ —É–¥–∞–ª–∞—Å—å")
                return False

        except Exception as e:
            print(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–¥–æ–±—Ä–µ–Ω–∏–∏ —Ç–æ–∫–µ–Ω–∞: {e}")
            return False

    def build_swap_commands(self, swap_params: SwapParams) -> tuple:
        """
        –°—Ç—Ä–æ–∏—Ç –∫–æ–º–∞–Ω–¥—ã –¥–ª—è UniversalRouter
        –ò—Å–ø–æ–ª—å–∑—É–µ—Ç –±–∏–±–ª–∏–æ—Ç–µ–∫—É uniswap-universal-router-decoder –µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–Ω–∞
        """
        if not ROUTER_DECODER_AVAILABLE:
            print("‚ùå –ë–∏–±–ª–∏–æ—Ç–µ–∫–∞ router decoder –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞, –∏—Å–ø–æ–ª—å–∑—É–µ–º —É–ø—Ä–æ—â–µ–Ω–Ω–æ–µ –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ")
            return self._build_simple_swap_commands(swap_params)

        try:
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º –±–∏–±–ª–∏–æ—Ç–µ–∫—É –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è –∫–æ–º–∞–Ω–¥
            commands = []
            inputs = []

            # –ö–æ–º–∞–Ω–¥–∞ V3_SWAP_EXACT_IN (0x00)
            command = 0x00
            commands.append(command)

            # –ö–æ–¥–∏—Ä—É–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —Å–≤–∞–ø–∞
            swap_input = encode_v3_swap(
                recipient=FunctionRecipient.SENDER,  # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–∞ –∞–¥—Ä–µ—Å –∏–Ω–∏—Ü–∏–∞—Ç–æ—Ä–∞
                amount_in=swap_params.amount_in,
                amount_out_min=swap_params.amount_out_min,
                path=self._encode_path(
                    swap_params.token_in,
                    swap_params.fee,
                    swap_params.token_out
                ),
                payer_is_sender=True
            )
            inputs.append(swap_input)

            # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –∫–æ–º–∞–Ω–¥—ã –≤ bytes
            commands_bytes = bytes(commands)

            return commands_bytes, inputs

        except Exception as e:
            print(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–∏ –∫–æ–º–∞–Ω–¥: {e}")
            return self._build_simple_swap_commands(swap_params)

    def _build_simple_swap_commands(self, swap_params: SwapParams) -> tuple:
        """–£–ø—Ä–æ—â–µ–Ω–Ω–æ–µ –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –∫–æ–º–∞–Ω–¥ (—Ñ–æ–ª–ª–±—ç–∫)"""
        # V3_SWAP_EXACT_IN –∫–æ–º–∞–Ω–¥–∞
        commands = bytes([0x00])

        # –ü—Ä–æ—Å—Ç–æ–µ –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
        # –í —Ä–µ–∞–ª—å–Ω–æ—Å—Ç–∏ —Ç—Ä–µ–±—É–µ—Ç—Å—è –±–æ–ª–µ–µ —Å–ª–æ–∂–Ω–∞—è –ª–æ–≥–∏–∫–∞
        swap_data = self.w3.eth.abi.encode(
            ['address', 'uint256', 'uint256', 'bytes', 'bool'],
            [
                swap_params.recipient,
                swap_params.amount_in,
                swap_params.amount_out_min,
                self._encode_path_simple(
                    swap_params.token_in,
                    swap_params.fee,
                    swap_params.token_out
                ),
                False  # unwrapWETH
            ]
        )

        return commands, [swap_data]

    def _encode_path(self, token_a: str, fee: int, token_b: str) -> bytes:
        """–ö–æ–¥–∏—Ä—É–µ—Ç –ø—É—Ç—å –¥–ª—è V3 —Å–≤–∞–ø–∞ (token -> fee -> token)"""
        # –ü—É—Ç—å –≤ V3: tokenA (20 bytes) + fee (3 bytes) + tokenB (20 bytes)
        path = (
                bytes.fromhex(token_a[2:]) +  # –£–±–∏—Ä–∞–µ–º 0x
                fee.to_bytes(3, 'big') +  # –ö–æ–º–∏—Å—Å–∏—è –≤ 3 –±–∞–π—Ç–∞—Ö
                bytes.fromhex(token_b[2:])  # –£–±–∏—Ä–∞–µ–º 0x
        )
        return path

    def _encode_path_simple(self, token_a: str, fee: int, token_b: str) -> bytes:
        """–£–ø—Ä–æ—â–µ–Ω–Ω–æ–µ –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ –ø—É—Ç–∏"""
        return self._encode_path(token_a, fee, token_b)

    def execute_swap(self, token_in_address: str, token_out_address: str,
                     amount_in_human: float, slippage_percent: float = 0.5,
                     fee: int = 3000) -> bool:
        """
        –í—ã–ø–æ–ª–Ω—è–µ—Ç —Å–≤–∞–ø —Ç–æ–∫–µ–Ω–æ–≤ —á–µ—Ä–µ–∑ UniversalRouter

        Args:
            token_in_address: –ê–¥—Ä–µ—Å –≤—Ö–æ–¥—è—â–µ–≥–æ —Ç–æ–∫–µ–Ω–∞
            token_out_address: –ê–¥—Ä–µ—Å –∏—Å—Ö–æ–¥—è—â–µ–≥–æ —Ç–æ–∫–µ–Ω–∞
            amount_in_human: –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–æ–∫–µ–Ω–æ–≤ –¥–ª—è —Å–≤–∞–ø–∞
            slippage_percent: –ü—Ä–æ—Å–∫–∞–ª—å–∑—ã–≤–∞–Ω–∏–µ –≤ –ø—Ä–æ—Ü–µ–Ω—Ç–∞—Ö
            fee: –ö–æ–º–∏—Å—Å–∏—è –ø—É–ª–∞ (3000 = 0.3%, 500 = 0.05%, 10000 = 1%)
        """

        print(f"\n{'=' * 60}")
        print(f"üîÑ –ù–ê–ß–ò–ù–ê–ï–ú –°–í–ê–ü –¢–û–ö–ï–ù–û–í")
        print(f"{'=' * 60}")

        # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ç–æ–∫–µ–Ω–∞—Ö
        token_in_info = self.get_token_info(token_in_address)
        token_out_info = self.get_token_info(token_out_address)

        if not token_in_info or not token_out_info:
            print("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ç–æ–∫–µ–Ω–∞—Ö")
            return False

        print(f"üì• –í—Ö–æ–¥—è—â–∏–π —Ç–æ–∫–µ–Ω: {token_in_info['symbol']} ({token_in_address})")
        print(f"üí∞ –ë–∞–ª–∞–Ω—Å: {token_in_info['balance_formatted']:.6f}")
        print(f"üì§ –ò—Å—Ö–æ–¥—è—â–∏–π —Ç–æ–∫–µ–Ω: {token_out_info['symbol']} ({token_out_address})")
        print(f"üí∞ –ë–∞–ª–∞–Ω—Å: {token_out_info['balance_formatted']:.6f}")
        print(f"üìä –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–ª—è —Å–≤–∞–ø–∞: {amount_in_human}")
        print(f"üìà –ü—Ä–æ—Å–∫–∞–ª—å–∑—ã–≤–∞–Ω–∏–µ: {slippage_percent}%")
        print(f"üí∏ –ö–æ–º–∏—Å—Å–∏—è –ø—É–ª–∞: {fee / 10000}%")

        # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º —Å—É–º–º—É –≤ wei
        amount_in_wei = int(amount_in_human * (10 ** token_in_info['decimals']))

        if token_in_info['balance'] < amount_in_wei:
            print(
                f"‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Ç–æ–∫–µ–Ω–æ–≤! –¢—Ä–µ–±—É–µ—Ç—Å—è: {amount_in_human}, –¥–æ—Å—Ç—É–ø–Ω–æ: {token_in_info['balance_formatted']:.6f}")
            return False

        # –û–¥–æ–±—Ä—è–µ–º —Ç–æ–∫–µ–Ω –¥–ª—è Permit2
        if not self.approve_token_for_permit2(token_in_address, amount_in_wei):
            return False

        # –ü–æ–ª—É—á–∞–µ–º –∫–æ—Ç–∏—Ä–æ–≤–∫—É
        print(f"\nüîç –ü–æ–ª—É—á–∞–µ–º –∫–æ—Ç–∏—Ä–æ–≤–∫—É...")
        amount_out = self.get_quote_from_quoter(
            token_in_address,
            token_out_address,
            amount_in_wei,
            fee
        )

        if not amount_out:
            print("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∫–æ—Ç–∏—Ä–æ–≤–∫—É")
            return False

        amount_out_formatted = amount_out / (10 ** token_out_info['decimals'])
        print(f"üí± –û–∂–∏–¥–∞–µ–º–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ: {amount_out_formatted:.6f} {token_out_info['symbol']}")

        # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –º–∏–Ω–∏–º–∞–ª—å–Ω—É—é —Å—É–º–º—É —Å —É—á–µ—Ç–æ–º –ø—Ä–æ—Å–∫–∞–ª—å–∑—ã–≤–∞–Ω–∏—è
        amount_out_min = int(amount_out * (100 - slippage_percent) / 100)
        amount_out_min_formatted = amount_out_min / (10 ** token_out_info['decimals'])
        print(f"üìâ –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Å—É–º–º–∞: {amount_out_min_formatted:.6f} {token_out_info['symbol']}")

        # –°—Ç—Ä–æ–∏–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —Å–≤–∞–ø–∞
        deadline = int(time.time()) + 1800  # 30 –º–∏–Ω—É—Ç
        swap_params = SwapParams(
            token_in=token_in_address,
            token_out=token_out_address,
            amount_in=amount_in_wei,
            amount_out_min=amount_out_min,
            recipient=self.account.address,
            deadline=deadline,
            fee=fee
        )

        # –°—Ç—Ä–æ–∏–º –∫–æ–º–∞–Ω–¥—ã –¥–ª—è UniversalRouter
        print(f"\n‚öôÔ∏è  –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º –∫–æ–º–∞–Ω–¥—ã –¥–ª—è UniversalRouter...")
        commands, inputs = self.build_swap_commands(swap_params)

        try:
            # –°—Ç—Ä–æ–∏–º —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é
            tx_data = self.universal_router.functions.execute(
                commands,
                inputs,
                deadline
            ).build_transaction({
                'from': self.account.address,
                'gas': 300000,  # –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –ª–∏–º–∏—Ç –≥–∞–∑–∞
                'gasPrice': int(self.w3.eth.gas_price * 1.1),  # +10% –∫ —Ü–µ–Ω–µ –≥–∞–∑–∞
                'nonce': self.w3.eth.get_transaction_count(self.account.address),
                'value': 0  # –ù–µ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º ETH (–µ—Å–ª–∏ –Ω–µ —Å–≤–∞–ø–∞–µ–º ETH)
            })

            # –ü–æ–¥–ø–∏—Å—ã–≤–∞–µ–º —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é
            signed_tx = self.account.sign_transaction(tx_data)

            print(f"\nüöÄ –û–¢–ü–†–ê–í–õ–Ø–ï–ú –¢–†–ê–ù–ó–ê–ö–¶–ò–Æ –°–í–ê–ü–ê...")
            print(f"‚õΩ –ì–∞–∑: {tx_data['gas']:,}")
            print(f"üí∞ –¶–µ–Ω–∞ –≥–∞–∑–∞: {tx_data['gasPrice']:,} wei")
            print(f"üí∏ –°—Ç–æ–∏–º–æ—Å—Ç—å –≥–∞–∑–∞: {self.w3.from_wei(tx_data['gas'] * tx_data['gasPrice'], 'ether'):.6f} ETH")

            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é
            tx_hash = self.w3.eth.send_raw_transaction(signed_tx.rawTransaction)
            print(f"üì§ –¢—Ä–∞–Ω–∑–∞–∫—Ü–∏—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞: {tx_hash.hex()}")

            # –ñ–¥–µ–º –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è
            print(f"‚è≥ –û–∂–∏–¥–∞–µ–º –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è...")
            receipt = self.w3.eth.wait_for_transaction_receipt(tx_hash, timeout=300)

            if receipt.status == 1:
                print(f"\nüéâ –°–í–ê–ü –£–°–ü–ï–®–ù–û –í–´–ü–û–õ–ù–ï–ù!")
                print(f"‚úÖ –•—ç—à —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏: {tx_hash.hex()}")
                print(f"‚õΩ –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–æ –≥–∞–∑–∞: {receipt.gasUsed:,}")

                # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ –±–∞–ª–∞–Ω—Å—ã
                print(f"\nüìä –û–ë–ù–û–í–õ–ï–ù–ù–´–ï –ë–ê–õ–ê–ù–°–´:")
                updated_token_in = self.get_token_info(token_in_address)
                updated_token_out = self.get_token_info(token_out_address)

                if updated_token_in and updated_token_out:
                    print(f"üì• {updated_token_in['symbol']}: {updated_token_in['balance_formatted']:.6f}")
                    print(f"üì§ {updated_token_out['symbol']}: {updated_token_out['balance_formatted']:.6f}")

                return True
            else:
                print(f"‚ùå –¢—Ä–∞–Ω–∑–∞–∫—Ü–∏—è –Ω–µ —É–¥–∞–ª–∞—Å—å")
                return False

        except Exception as e:
            print(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–∏ —Å–≤–∞–ø–∞: {e}")
            return False


def main():
    """–û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏"""

    # –ó–∞–≥—Ä—É–∂–∞–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è
    load_dotenv()

    # –ü–æ–ª—É—á–∞–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é
    private_key = os.getenv('PRIVATE_KEY')
    rpc_url = os.getenv('RPC_URL', 'https://eth-mainnet.g.alchemy.com/v2/YOUR_API_KEY')

    if not private_key:
        print("‚ùå PRIVATE_KEY –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è")
        print("–î–æ–±–∞–≤—å—Ç–µ –≤ —Ñ–∞–π–ª .env: PRIVATE_KEY=your_private_key_here")
        return

    # –ü—Ä–∏–º–µ—Ä—ã —Ç–æ–∫–µ–Ω–æ–≤ (Ethereum Mainnet)
    USDC = "0xA0b86a33E6442141e26393e5f50c6cf1B740e1de"  # USDC
    WETH = "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2"  # WETH

    try:
        # –°–æ–∑–¥–∞–µ–º —Å–≤–∞–ø–µ—Ä
        swapper = AdvancedUniswapSwapper(
            private_key=private_key,
            rpc_url=rpc_url,
            chain_id=1  # Ethereum Mainnet
        )

        # –í—ã–ø–æ–ª–Ω—è–µ–º —Å–≤–∞–ø: 10 USDC -> WETH
        success = swapper.execute_swap(
            token_in_address=USDC,
            token_out_address=WETH,
            amount_in_human=10.0,  # 10 USDC
            slippage_percent=0.5,  # 0.5% –ø—Ä–æ—Å–∫–∞–ª—å–∑—ã–≤–∞–Ω–∏–µ
            fee=3000  # 0.3% –∫–æ–º–∏—Å—Å–∏—è –ø—É–ª–∞
        )

        if success:
            print(f"\nüéä –°–≤–∞–ø –∑–∞–≤–µ—Ä—à–µ–Ω —É—Å–ø–µ—à–Ω–æ!")
        else:
            print(f"\nüí• –°–≤–∞–ø –Ω–µ —É–¥–∞–ª—Å—è")

    except Exception as e:
        print(f"üí• –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: {e}")


if __name__ == "__main__":
    main()
